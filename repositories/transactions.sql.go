// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: transactions.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const createTransactionHistory = `-- name: CreateTransactionHistory :one
INSERT INTO transaction_history (
    "transaction_type",
    "from_account_id",
    "to_account_id",
    "to_merchant_id",
    "amount",
    "description"
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, transaction_type, from_account_id, to_account_id, to_merchant_id, amount, description, created_at
`

type CreateTransactionHistoryParams struct {
	TransactionType TransactionType `json:"transaction_type"`
	FromAccountID   uuid.UUID       `json:"from_account_id"`
	ToAccountID     uuid.NullUUID   `json:"to_account_id"`
	ToMerchantID    uuid.NullUUID   `json:"to_merchant_id"`
	Amount          float64         `json:"amount"`
	Description     string          `json:"description"`
}

func (q *Queries) CreateTransactionHistory(ctx context.Context, arg CreateTransactionHistoryParams) (TransactionHistory, error) {
	row := q.db.QueryRowContext(ctx, createTransactionHistory,
		arg.TransactionType,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.ToMerchantID,
		arg.Amount,
		arg.Description,
	)
	var i TransactionHistory
	err := row.Scan(
		&i.ID,
		&i.TransactionType,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.ToMerchantID,
		&i.Amount,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getTransactionHistory = `-- name: GetTransactionHistory :many
SELECT id, transaction_type, from_account_id, to_account_id, to_merchant_id, amount, description, created_at FROM transaction_history 
WHERE from_account_id = $1
`

func (q *Queries) GetTransactionHistory(ctx context.Context, fromAccountID uuid.UUID) ([]TransactionHistory, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionHistory, fromAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionHistory{}
	for rows.Next() {
		var i TransactionHistory
		if err := rows.Scan(
			&i.ID,
			&i.TransactionType,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.ToMerchantID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionHistoryByType = `-- name: GetTransactionHistoryByType :many
SELECT id, transaction_type, from_account_id, to_account_id, to_merchant_id, amount, description, created_at FROM transaction_history 
WHERE transaction_type = $1 AND from_account_id = $2
`

type GetTransactionHistoryByTypeParams struct {
	TransactionType TransactionType `json:"transaction_type"`
	FromAccountID   uuid.UUID       `json:"from_account_id"`
}

func (q *Queries) GetTransactionHistoryByType(ctx context.Context, arg GetTransactionHistoryByTypeParams) ([]TransactionHistory, error) {
	rows, err := q.db.QueryContext(ctx, getTransactionHistoryByType, arg.TransactionType, arg.FromAccountID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionHistory{}
	for rows.Next() {
		var i TransactionHistory
		if err := rows.Scan(
			&i.ID,
			&i.TransactionType,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.ToMerchantID,
			&i.Amount,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
