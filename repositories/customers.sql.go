// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: customers.sql

package repositories

import (
	"context"

	"github.com/google/uuid"
)

const createCustomer = `-- name: CreateCustomer :one
INSERT INTO m_customer (
    "id_card_type",
    "id_card_number",
    "id_card_file",
    "first_name",
    "last_name",
    "phone_number",
    "email",
    "username",
    "password"
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, role, id_card_type, id_card_number, id_card_file, first_name, last_name, phone_number, email, username, password, status, created_at, updated_at
`

type CreateCustomerParams struct {
	IDCardType   IDCardType `json:"id_card_type"`
	IDCardNumber string     `json:"id_card_number"`
	IDCardFile   string     `json:"id_card_file"`
	FirstName    string     `json:"first_name"`
	LastName     string     `json:"last_name"`
	PhoneNumber  string     `json:"phone_number"`
	Email        string     `json:"email"`
	Username     string     `json:"username"`
	Password     string     `json:"password"`
}

func (q *Queries) CreateCustomer(ctx context.Context, arg CreateCustomerParams) (MCustomer, error) {
	row := q.db.QueryRowContext(ctx, createCustomer,
		arg.IDCardType,
		arg.IDCardNumber,
		arg.IDCardFile,
		arg.FirstName,
		arg.LastName,
		arg.PhoneNumber,
		arg.Email,
		arg.Username,
		arg.Password,
	)
	var i MCustomer
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.IDCardType,
		&i.IDCardNumber,
		&i.IDCardFile,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllCustomers = `-- name: GetAllCustomers :many
SELECT id, role, id_card_type, id_card_number, id_card_file, first_name, last_name, phone_number, email, username, password, status, created_at, updated_at FROM m_customer
LIMIT $1 OFFSET $2
`

type GetAllCustomersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAllCustomers(ctx context.Context, arg GetAllCustomersParams) ([]MCustomer, error) {
	rows, err := q.db.QueryContext(ctx, getAllCustomers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []MCustomer{}
	for rows.Next() {
		var i MCustomer
		if err := rows.Scan(
			&i.ID,
			&i.Role,
			&i.IDCardType,
			&i.IDCardNumber,
			&i.IDCardFile,
			&i.FirstName,
			&i.LastName,
			&i.PhoneNumber,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT "id", "role", "username", "email", "password", "status" FROM m_customer WHERE email = $1
`

type GetCustomerByEmailRow struct {
	ID       uuid.UUID    `json:"id"`
	Role     Role         `json:"role"`
	Username string       `json:"username"`
	Email    string       `json:"email"`
	Password string       `json:"password"`
	Status   CustomerEnum `json:"status"`
}

func (q *Queries) GetCustomerByEmail(ctx context.Context, email string) (GetCustomerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByEmail, email)
	var i GetCustomerByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Status,
	)
	return i, err
}

const getCustomerById = `-- name: GetCustomerById :one
SELECT id, role, id_card_type, id_card_number, id_card_file, first_name, last_name, phone_number, email, username, password, status, created_at, updated_at FROM m_customer WHERE "id" = $1
`

func (q *Queries) GetCustomerById(ctx context.Context, id uuid.UUID) (MCustomer, error) {
	row := q.db.QueryRowContext(ctx, getCustomerById, id)
	var i MCustomer
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.IDCardType,
		&i.IDCardNumber,
		&i.IDCardFile,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCustomerByUsername = `-- name: GetCustomerByUsername :one
SELECT "id", "role", "username", "email", "password", "status" FROM m_customer WHERE username = $1
`

type GetCustomerByUsernameRow struct {
	ID       uuid.UUID    `json:"id"`
	Role     Role         `json:"role"`
	Username string       `json:"username"`
	Email    string       `json:"email"`
	Password string       `json:"password"`
	Status   CustomerEnum `json:"status"`
}

func (q *Queries) GetCustomerByUsername(ctx context.Context, username string) (GetCustomerByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByUsername, username)
	var i GetCustomerByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.Username,
		&i.Email,
		&i.Password,
		&i.Status,
	)
	return i, err
}

const updateCustomer = `-- name: UpdateCustomer :one
UPDATE m_customer
SET "id_card_type" = $2, "id_card_number" = $3, "id_card_file" = $4, "status" = $5
WHERE "id" = $1 RETURNING id, role, id_card_type, id_card_number, id_card_file, first_name, last_name, phone_number, email, username, password, status, created_at, updated_at
`

type UpdateCustomerParams struct {
	ID           uuid.UUID    `json:"id"`
	IDCardType   IDCardType   `json:"id_card_type"`
	IDCardNumber string       `json:"id_card_number"`
	IDCardFile   string       `json:"id_card_file"`
	Status       CustomerEnum `json:"status"`
}

func (q *Queries) UpdateCustomer(ctx context.Context, arg UpdateCustomerParams) (MCustomer, error) {
	row := q.db.QueryRowContext(ctx, updateCustomer,
		arg.ID,
		arg.IDCardType,
		arg.IDCardNumber,
		arg.IDCardFile,
		arg.Status,
	)
	var i MCustomer
	err := row.Scan(
		&i.ID,
		&i.Role,
		&i.IDCardType,
		&i.IDCardNumber,
		&i.IDCardFile,
		&i.FirstName,
		&i.LastName,
		&i.PhoneNumber,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
